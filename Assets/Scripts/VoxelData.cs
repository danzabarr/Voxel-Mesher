using System.Collections.Generic;
using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering;

[CreateAssetMenu(fileName = "VoxelData", menuName = "VoxelData")]
public class VoxelData : ScriptableObject
{
    public int version;
    public Vector3Int size;
    public List<Voxel> voxels = new List<Voxel>();
    public Color32[] palette = new Color32[256];
    public delegate bool Filter(Vector3Int pos, int index);
    public static VoxelData Read(string assetPath)
    {
        string name = Path.GetFileNameWithoutExtension(assetPath);
        byte[] bytes = File.ReadAllBytes(assetPath);
        using BinaryReader reader = new BinaryReader(new MemoryStream(bytes));

        string magic = Encoding.ASCII.GetString(reader.ReadBytes(4));

        if (magic != "VOX ")
        {
            Debug.LogError("Not a valid .vox file");
            return null;
        }

        VoxelData data = ScriptableObject.CreateInstance<VoxelData>();
        data.version = reader.ReadInt32();
        data.name = name + "_data";
        data.palette = new Color32[256];

        // Process chunks
        while (reader.BaseStream.Position < reader.BaseStream.Length)
        {
            // Read chunk header
            string chunkId = Encoding.ASCII.GetString(reader.ReadBytes(4)); // Chunk ID
            int chunkSize = reader.ReadInt32(); // Size of chunk data
            int childrenSize = reader.ReadInt32(); // Size of children chunks

            //Debug.Log($"Chunk ID: {chunkId}, Chunk Size: {chunkSize}, Children Size: {childrenSize}");

            long startPosition = reader.BaseStream.Position;

            if (chunkId == "MAIN")
            {
                // MAIN chunk: just continue to process its children
            }
            else if (chunkId == "PACK")
            {
                int numModels = reader.ReadInt32();
                //Debug.Log($"Number of models: {numModels}");
            }
            else if (chunkId == "SIZE")
            {
                int x = reader.ReadInt32();
                int z = reader.ReadInt32();
                int y = reader.ReadInt32();
                //Debug.Log($"SIZE chunk: x={x}, y={y}, z={z}");
                data.size = new Vector3Int(x, y, z);
                // Set up your mesh dimensions or any other logic here
            }
            else if (chunkId == "XYZI")
            {
                int numVoxels = reader.ReadInt32();
                //Debug.Log($"Number of voxels: {numVoxels}");
                for (int i = 0; i < numVoxels; i++)
                {
                    byte vx = reader.ReadByte();
                    byte vz = reader.ReadByte();
                    byte vy = reader.ReadByte();
                    byte colorIndex = reader.ReadByte();

                    //Debug.Log($"Voxel {i}: x={vx}, y={vy}, z={vz}, colorIndex={colorIndex}");
                    //voxels[new Vector3Int(vx, vy, vz)] = colorIndex;
                    // Create voxel mesh logic here if needed, e.g., voxelMesh.vertices, etc.
                    data.voxels.Add(new Voxel(vx, vy, vz, colorIndex));

                }
            }
            else if (chunkId == "RGBA")
            {
                //Debug.Log("Reading palette...");
                for (int i = 0; i < 256; i++)
                {
                    byte r = reader.ReadByte();
                    byte g = reader.ReadByte();
                    byte b = reader.ReadByte();
                    byte a = reader.ReadByte();
                    data.palette[i] = new Color32(r, g, b, a);
                    //Debug.Log($"Color {i}: R={r}, G={g}, B={b}, A={a}");
                }
            }
            else
            {
                //Debug.Log($"Skipping unknown chunk: {chunkId}");
                Debug.LogWarning($"Skipping unknown chunk: {chunkId}");
                
                //read the chunk data and print it out so we can see what it is
                byte[] chunkData = reader.ReadBytes(chunkSize);
                string chunkDataString = Encoding.ASCII.GetString(chunkData);
                Debug.Log(chunkDataString);
            }

            // Check if the chunk has been fully processed, and skip remaining bytes if needed
            long bytesRead = reader.BaseStream.Position - startPosition;
            if (bytesRead < chunkSize)
            {
                reader.BaseStream.Seek(chunkSize - bytesRead, SeekOrigin.Current);  // Skip remaining unread bytes
            }
        }
        return data;
    }

    public static readonly Color32[] defaultPalette = new Color32[]
    {
        new Color32(0xff, 0xff, 0xff, 0xff), new Color32(0xff, 0xff, 0xcc, 0xff), new Color32(0xff, 0xff, 0x99, 0xff), new Color32(0xff, 0xff, 0x66, 0xff), new Color32(0xff, 0xff, 0x33, 0xff), new Color32(0xff, 0xff, 0x00, 0xff), new Color32(0xff, 0xcc, 0xff, 0xff), new Color32(0xff, 0xcc, 0xcc, 0xff), 
        new Color32(0xff, 0xcc, 0x99, 0xff), new Color32(0xff, 0xcc, 0x66, 0xff), new Color32(0xff, 0xcc, 0x33, 0xff), new Color32(0xff, 0xcc, 0x00, 0xff), new Color32(0xff, 0x99, 0xff, 0xff), new Color32(0xff, 0x99, 0xcc, 0xff), new Color32(0xff, 0x99, 0x99, 0xff), new Color32(0xff, 0x99, 0x66, 0xff), 
        new Color32(0xff, 0x99, 0x33, 0xff), new Color32(0xff, 0x99, 0x00, 0xff), new Color32(0xff, 0x66, 0xff, 0xff), new Color32(0xff, 0x66, 0xcc, 0xff), new Color32(0xff, 0x66, 0x99, 0xff), new Color32(0xff, 0x66, 0x66, 0xff), new Color32(0xff, 0x66, 0x33, 0xff), new Color32(0xff, 0x66, 0x00, 0xff), 
        new Color32(0xff, 0x33, 0xff, 0xff), new Color32(0xff, 0x33, 0xcc, 0xff), new Color32(0xff, 0x33, 0x99, 0xff), new Color32(0xff, 0x33, 0x66, 0xff), new Color32(0xff, 0x33, 0x33, 0xff), new Color32(0xff, 0x33, 0x00, 0xff), new Color32(0xff, 0x00, 0xff, 0xff), new Color32(0xff, 0x00, 0xcc, 0xff), 
        new Color32(0xff, 0x00, 0x99, 0xff), new Color32(0xff, 0x00, 0x66, 0xff), new Color32(0xff, 0x00, 0x33, 0xff), new Color32(0xff, 0x00, 0x00, 0xff), new Color32(0xcc, 0xff, 0xff, 0xff), new Color32(0xcc, 0xff, 0xcc, 0xff), new Color32(0xcc, 0xff, 0x99, 0xff), new Color32(0xcc, 0xff, 0x66, 0xff), 
        new Color32(0xcc, 0xff, 0x33, 0xff), new Color32(0xcc, 0xff, 0x00, 0xff), new Color32(0xcc, 0xcc, 0xff, 0xff), new Color32(0xcc, 0xcc, 0xcc, 0xff), new Color32(0xcc, 0xcc, 0x99, 0xff), new Color32(0xcc, 0xcc, 0x66, 0xff), new Color32(0xcc, 0xcc, 0x33, 0xff), new Color32(0xcc, 0xcc, 0x00, 0xff), 
        new Color32(0xcc, 0x99, 0xff, 0xff), new Color32(0xcc, 0x99, 0xcc, 0xff), new Color32(0xcc, 0x99, 0x99, 0xff), new Color32(0xcc, 0x99, 0x66, 0xff), new Color32(0xcc, 0x99, 0x33, 0xff), new Color32(0xcc, 0x99, 0x00, 0xff), new Color32(0xcc, 0x66, 0xff, 0xff), new Color32(0xcc, 0x66, 0xcc, 0xff), 
        new Color32(0xcc, 0x66, 0x99, 0xff), new Color32(0xcc, 0x66, 0x66, 0xff), new Color32(0xcc, 0x66, 0x33, 0xff), new Color32(0xcc, 0x66, 0x00, 0xff), new Color32(0xcc, 0x33, 0xff, 0xff), new Color32(0xcc, 0x33, 0xcc, 0xff), new Color32(0xcc, 0x33, 0x99, 0xff), new Color32(0xcc, 0x33, 0x66, 0xff), 
        new Color32(0xcc, 0x33, 0x33, 0xff), new Color32(0xcc, 0x33, 0x00, 0xff), new Color32(0xcc, 0x00, 0xff, 0xff), new Color32(0xcc, 0x00, 0xcc, 0xff), new Color32(0xcc, 0x00, 0x99, 0xff), new Color32(0xcc, 0x00, 0x66, 0xff), new Color32(0xcc, 0x00, 0x33, 0xff), new Color32(0xcc, 0x00, 0x00, 0xff), 
        new Color32(0x99, 0xff, 0xff, 0xff), new Color32(0x99, 0xff, 0xcc, 0xff), new Color32(0x99, 0xff, 0x99, 0xff), new Color32(0x99, 0xff, 0x66, 0xff), new Color32(0x99, 0xff, 0x33, 0xff), new Color32(0x99, 0xff, 0x00, 0xff), new Color32(0x99, 0xcc, 0xff, 0xff), new Color32(0x99, 0xcc, 0xcc, 0xff), 
        new Color32(0x99, 0xcc, 0x99, 0xff), new Color32(0x99, 0xcc, 0x66, 0xff), new Color32(0x99, 0xcc, 0x33, 0xff), new Color32(0x99, 0xcc, 0x00, 0xff), new Color32(0x99, 0x99, 0xff, 0xff), new Color32(0x99, 0x99, 0xcc, 0xff), new Color32(0x99, 0x99, 0x99, 0xff), new Color32(0x99, 0x99, 0x66, 0xff), 
        new Color32(0x99, 0x99, 0x33, 0xff), new Color32(0x99, 0x99, 0x00, 0xff), new Color32(0x99, 0x66, 0xff, 0xff), new Color32(0x99, 0x66, 0xcc, 0xff), new Color32(0x99, 0x66, 0x99, 0xff), new Color32(0x99, 0x66, 0x66, 0xff), new Color32(0x99, 0x66, 0x33, 0xff), new Color32(0x99, 0x66, 0x00, 0xff), 
        new Color32(0x99, 0x33, 0xff, 0xff), new Color32(0x99, 0x33, 0xcc, 0xff), new Color32(0x99, 0x33, 0x99, 0xff), new Color32(0x99, 0x33, 0x66, 0xff), new Color32(0x99, 0x33, 0x33, 0xff), new Color32(0x99, 0x33, 0x00, 0xff), new Color32(0x99, 0x00, 0xff, 0xff), new Color32(0x99, 0x00, 0xcc, 0xff), 
        new Color32(0x99, 0x00, 0x99, 0xff), new Color32(0x99, 0x00, 0x66, 0xff), new Color32(0x99, 0x00, 0x33, 0xff), new Color32(0x99, 0x00, 0x00, 0xff), new Color32(0x66, 0xff, 0xff, 0xff), new Color32(0x66, 0xff, 0xcc, 0xff), new Color32(0x66, 0xff, 0x99, 0xff), new Color32(0x66, 0xff, 0x66, 0xff), 
        new Color32(0x66, 0xff, 0x33, 0xff), new Color32(0x66, 0xff, 0x00, 0xff), new Color32(0x66, 0xcc, 0xff, 0xff), new Color32(0x66, 0xcc, 0xcc, 0xff), new Color32(0x66, 0xcc, 0x99, 0xff), new Color32(0x66, 0xcc, 0x66, 0xff), new Color32(0x66, 0xcc, 0x33, 0xff), new Color32(0x66, 0xcc, 0x00, 0xff), 
        new Color32(0x66, 0x99, 0xff, 0xff), new Color32(0x66, 0x99, 0xcc, 0xff), new Color32(0x66, 0x99, 0x99, 0xff), new Color32(0x66, 0x99, 0x66, 0xff), new Color32(0x66, 0x99, 0x33, 0xff), new Color32(0x66, 0x99, 0x00, 0xff), new Color32(0x66, 0x66, 0xff, 0xff), new Color32(0x66, 0x66, 0xcc, 0xff), 
        new Color32(0x66, 0x66, 0x99, 0xff), new Color32(0x66, 0x66, 0x66, 0xff), new Color32(0x66, 0x66, 0x33, 0xff), new Color32(0x66, 0x66, 0x00, 0xff), new Color32(0x66, 0x33, 0xff, 0xff), new Color32(0x66, 0x33, 0xcc, 0xff), new Color32(0x66, 0x33, 0x99, 0xff), new Color32(0x66, 0x33, 0x66, 0xff), 
        new Color32(0x66, 0x33, 0x33, 0xff), new Color32(0x66, 0x33, 0x00, 0xff), new Color32(0x66, 0x00, 0xff, 0xff), new Color32(0x66, 0x00, 0xcc, 0xff), new Color32(0x66, 0x00, 0x99, 0xff), new Color32(0x66, 0x00, 0x66, 0xff), new Color32(0x66, 0x00, 0x33, 0xff), new Color32(0x66, 0x00, 0x00, 0xff), 
        new Color32(0x33, 0xff, 0xff, 0xff), new Color32(0x33, 0xff, 0xcc, 0xff), new Color32(0x33, 0xff, 0x99, 0xff), new Color32(0x33, 0xff, 0x66, 0xff), new Color32(0x33, 0xff, 0x33, 0xff), new Color32(0x33, 0xff, 0x00, 0xff), new Color32(0x33, 0xcc, 0xff, 0xff), new Color32(0x33, 0xcc, 0xcc, 0xff), 
        new Color32(0x33, 0xcc, 0x99, 0xff), new Color32(0x33, 0xcc, 0x66, 0xff), new Color32(0x33, 0xcc, 0x33, 0xff), new Color32(0x33, 0xcc, 0x00, 0xff), new Color32(0x33, 0x99, 0xff, 0xff), new Color32(0x33, 0x99, 0xcc, 0xff), new Color32(0x33, 0x99, 0x99, 0xff), new Color32(0x33, 0x99, 0x66, 0xff), 
        new Color32(0x33, 0x99, 0x33, 0xff), new Color32(0x33, 0x99, 0x00, 0xff), new Color32(0x33, 0x66, 0xff, 0xff), new Color32(0x33, 0x66, 0xcc, 0xff), new Color32(0x33, 0x66, 0x99, 0xff), new Color32(0x33, 0x66, 0x66, 0xff), new Color32(0x33, 0x66, 0x33, 0xff), new Color32(0x33, 0x66, 0x00, 0xff), 
        new Color32(0x33, 0x33, 0xff, 0xff), new Color32(0x33, 0x33, 0xcc, 0xff), new Color32(0x33, 0x33, 0x99, 0xff), new Color32(0x33, 0x33, 0x66, 0xff), new Color32(0x33, 0x33, 0x33, 0xff), new Color32(0x33, 0x33, 0x00, 0xff), new Color32(0x33, 0x00, 0xff, 0xff), new Color32(0x33, 0x00, 0xcc, 0xff), 
        new Color32(0x33, 0x00, 0x99, 0xff), new Color32(0x33, 0x00, 0x66, 0xff), new Color32(0x33, 0x00, 0x33, 0xff), new Color32(0x33, 0x00, 0x00, 0xff), new Color32(0x00, 0xff, 0xff, 0xff), new Color32(0x00, 0xff, 0xcc, 0xff), new Color32(0x00, 0xff, 0x99, 0xff), new Color32(0x00, 0xff, 0x66, 0xff), 
        new Color32(0x00, 0xff, 0x33, 0xff), new Color32(0x00, 0xff, 0x00, 0xff), new Color32(0x00, 0xcc, 0xff, 0xff), new Color32(0x00, 0xcc, 0xcc, 0xff), new Color32(0x00, 0xcc, 0x99, 0xff), new Color32(0x00, 0xcc, 0x66, 0xff), new Color32(0x00, 0xcc, 0x33, 0xff), new Color32(0x00, 0xcc, 0x00, 0xff), 
        new Color32(0x00, 0x99, 0xff, 0xff), new Color32(0x00, 0x99, 0xcc, 0xff), new Color32(0x00, 0x99, 0x99, 0xff), new Color32(0x00, 0x99, 0x66, 0xff), new Color32(0x00, 0x99, 0x33, 0xff), new Color32(0x00, 0x99, 0x00, 0xff), new Color32(0x00, 0x66, 0xff, 0xff), new Color32(0x00, 0x66, 0xcc, 0xff), 
        new Color32(0x00, 0x66, 0x99, 0xff), new Color32(0x00, 0x66, 0x66, 0xff), new Color32(0x00, 0x66, 0x33, 0xff), new Color32(0x00, 0x66, 0x00, 0xff), new Color32(0x00, 0x33, 0xff, 0xff), new Color32(0x00, 0x33, 0xcc, 0xff), new Color32(0x00, 0x33, 0x99, 0xff), new Color32(0x00, 0x33, 0x66, 0xff), 
        new Color32(0x00, 0x33, 0x33, 0xff), new Color32(0x00, 0x33, 0x00, 0xff), new Color32(0x00, 0x00, 0xff, 0xff), new Color32(0x00, 0x00, 0xcc, 0xff), new Color32(0x00, 0x00, 0x99, 0xff), new Color32(0x00, 0x00, 0x66, 0xff), new Color32(0x00, 0x00, 0x33, 0xff), new Color32(0x00, 0x00, 0x00, 0xff),
        new Color32(0xee, 0x00, 0x00, 0xff), new Color32(0xdd, 0x00, 0x00, 0xff), new Color32(0xbb, 0x00, 0x00, 0xff), new Color32(0xaa, 0x00, 0x00, 0xff), new Color32(0x88, 0x00, 0x00, 0xff), new Color32(0x77, 0x00, 0x00, 0xff), new Color32(0x55, 0x00, 0x00, 0xff), new Color32(0x44, 0x00, 0x00, 0xff), 
        new Color32(0x22, 0x00, 0x00, 0xff), new Color32(0x11, 0x00, 0x00, 0xff), new Color32(0x00, 0xee, 0x00, 0xff), new Color32(0x00, 0xdd, 0x00, 0xff), new Color32(0x00, 0xbb, 0x00, 0xff), new Color32(0x00, 0xaa, 0x00, 0xff), new Color32(0x00, 0x88, 0x00, 0xff), new Color32(0x00, 0x77, 0x00, 0xff), 
        new Color32(0x00, 0x55, 0x00, 0xff), new Color32(0x00, 0x44, 0x00, 0xff), new Color32(0x00, 0x22, 0x00, 0xff), new Color32(0x00, 0x11, 0x00, 0xff), new Color32(0x00, 0x00, 0xee, 0xff), new Color32(0x00, 0x00, 0xdd, 0xff), new Color32(0x00, 0x00, 0xbb, 0xff), new Color32(0x00, 0x00, 0xaa, 0xff), 
        new Color32(0x00, 0x00, 0x88, 0xff), new Color32(0x00, 0x00, 0x77, 0xff), new Color32(0x00, 0x00, 0x55, 0xff), new Color32(0x00, 0x00, 0x44, 0xff), new Color32(0x00, 0x00, 0x22, 0xff), new Color32(0x00, 0x00, 0x11, 0xff), new Color32(0xee, 0xee, 0xee, 0xff), new Color32(0xdd, 0xdd, 0xdd, 0xff), 
        new Color32(0xbb, 0xbb, 0xbb, 0xff), new Color32(0xaa, 0xaa, 0xaa, 0xff), new Color32(0x88, 0x88, 0x88, 0xff), new Color32(0x77, 0x77, 0x77, 0xff), new Color32(0x55, 0x55, 0x55, 0xff), new Color32(0x44, 0x44, 0x44, 0xff), new Color32(0x22, 0x22, 0x22, 0xff), new Color32(0x11, 0x11, 0x11, 0xff), 
        //new Color32(0x00, 0x00, 0x00, 0xff)
    };

    public static void Write(string path, int version, Vector3Int size, List<Voxel> voxels, Color32[] palette)
    {
        if (palette == null)
            palette = defaultPalette;

        using (BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)))
        {
            // Write VOX magic number
            writer.Write(Encoding.ASCII.GetBytes("VOX "));

            // Write version number
            writer.Write(version);

            // Write MAIN chunk header (ID, Content Size, Children Size)
            writer.Write(Encoding.ASCII.GetBytes("MAIN"));
            writer.Write(0); // Content size (0 for MAIN)
            long mainChildrenSizePos = writer.BaseStream.Position;
            writer.Write(0); // Placeholder for children size

            // Write SIZE chunk
            writer.Write(Encoding.ASCII.GetBytes("SIZE"));
            writer.Write(12); // Content size (3 ints for x, y, z)
            writer.Write(0); // No children

            writer.Write(size.x);
            writer.Write(size.z);
            writer.Write(size.y);

            // Write XYZI chunk
            writer.Write(Encoding.ASCII.GetBytes("XYZI"));
            writer.Write(4 + voxels.Count * 4); // Content size (4 bytes for numVoxels + 4 bytes per voxel)
            writer.Write(0); // No children

            writer.Write(voxels.Count);
            foreach (var voxel in voxels)
            {
                //writer.Write((byte)(size.x - 1 - voxel.x));
                //writer.Write((byte)(size.z - 1 - voxel.z));
                writer.Write(voxel.x);
                writer.Write(voxel.z);
                writer.Write(voxel.y);
                writer.Write(voxel.i);
            }

            // Write RGBA chunk
            writer.Write(Encoding.ASCII.GetBytes("RGBA"));
            writer.Write(1024); // Content size (256 colors * 4 bytes)
            writer.Write(0); // No children

            foreach (var color in palette)
            {
                writer.Write(color.r);
                writer.Write(color.g);
                writer.Write(color.b);
                writer.Write(color.a);
            }

            // Update MAIN chunk's children size
            long mainChildrenSize = writer.BaseStream.Position - mainChildrenSizePos - 4;
            writer.Seek((int)mainChildrenSizePos, SeekOrigin.Begin);
            writer.Write((int)mainChildrenSize);
        }

        // the file will have a different save time than the original file
        AssetDatabase.Refresh();
    }

}
